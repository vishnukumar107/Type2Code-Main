const paragraph=["The building block of C++ that leads to Object-Oriented programming is a Class. It is a user-defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class. A class is like a blueprint for an object.For Example: Consider the Class of Cars. There may be many cars with different names and brand but all of them will share some common properties like all of them will have 4 wheels, Speed Limit, Mileage range etc. So here, Car is the class and wheels, speed limits, mileage are their properties. A Class is a user-defined data-type which has data members and member functions. Data members are the data variables and member functions are the functions used to manipulate these variables and together these data members and member functions define the properties and behaviour of the objects in a Class. In the above example of class Car, the data member will be speed limit, mileage etc and member functions can apply brakes, increase speed etc.We can say that a Class in C++ is a blue-print representing a group of objects which shares some common properties and behaviours.",
"An Object is an identifiable entity with some characteristics and behaviour. An Object is an instance of a Class. When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created) memory is allocated.Object take up space in memory and have an associated address like a record in pascal or structure or union in C.When a program is executed the objects interact by sending messages to one another.Each object contains data and code to manipulate the data. Objects can interact without having to know details of each other’s data or code, it is sufficient to know the type of message accepted and type of response returned by the objects.In normal terms, Encapsulation is defined as wrapping up of data and information under a single unit. In Object-Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.Consider a real-life example of encapsulation, in a company, there are different sections like the accounts section, finance section, sales section etc. The finance section handles all the financial transactions and keeps records of all the data related to finance. Similarly, the sales section handles all the sales-related activities and keeps records of all the sales. Now there may arise a situation when for some reason an official from the finance section needs all the data about sales in a particular month. In this case, he is not allowed to directly access the data of the sales section. He will first have to contact some other officer in the sales section and then request him to give the particular data.",
"Data abstraction is one of the most essential and important features of object-oriented programming in C++. Abstraction means displaying only essential information and hiding the details. Data abstraction refers to providing only essential information about the data to the outside world, hiding the background details or implementation.Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of the car or applying brakes will stop the car but he does not know about how on pressing accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of accelerator, brakes etc in the car. This is what abstraction is.Abstraction using Classes: We can implement Abstraction in C++ using classes. The class helps us to group data members and member functions using available access specifiers. A Class can decide which data member will be visible to the outside world and which is not.Abstraction in Header files: One more type of abstraction in C++ can be header files. For example, consider the pow() method present in math.h header file. Whenever we need to calculate the power of a number, we simply call the function pow() present in the math.h header file and pass the numbers as arguments without knowing the underlying algorithm according to which the function is actually calculating the power of numbers.",
"The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form.A person at the same time can have different characteristic. Like a man at the same time is a father, a husband, an employee. So the same person posses different behaviour in different situations. This is called polymorphism.An operation may exhibit different behaviours in different instances. The behaviour depends upon the types of data used in the operation.C++ supports operator overloading and function overloading.Operator Overloading: The process of making an operator to exhibit different behaviours in different instances is known as operator overloading.Function Overloading: Function overloading is using a single function name to perform different types of tasks.Polymorphism is extensively used in implementing inheritance.Suppose we have to write a function to add some integers, some times there are 2 integers, some times there are 3 integers. We can write the Addition Method with the same name having different parameters, the concerned method will be called according to parameters.",
"A function is a set of statements that take inputs, do some specific computation and produces output.The idea is to put some commonly or repeatedly done task together and make a function so that instead of writing the same code again and again for different inputs, we can call the function.Functions help us in reducing code redundancy. If functionality is performed at multiple places in software, then rather than writing the same code, again and again, we create a function and call it everywhere. This also helps in maintenance as we have to change at one place if we make future changes to the functionality.Functions make code modular. Consider a big file having many lines of codes. It becomes really simple to read and use the code if the code is divided into functions.Functions provide abstraction. For example, we can use library functions without worrying about their internal working.A function declaration tells the compiler about the number of parameters function takes, data-types of parameters and return type of function. Putting parameter names in function declaration is optional in the function declaration, but it is necessary to put them in the definition.",
"An operating system acts as an intermediary between the user of a computer and computer hardware. The purpose of an operating system is to provide an environment in which a user can execute programs in a convenient and efficient manner.An operating system is a software that manages the computer hardware. The hardware must provide appropriate mechanisms to ensure the correct operation of the computer system and to prevent user programs from interfering with the proper operation of the system.An operating system is a program that controls the execution of application programs and acts as an interface between the user of a computer and the computer hardware.A more common definition is that the operating system is the one program running at all times on the computer (usually called the kernel), with all else being application programs.An operating system is concerned with the allocation of resources and services, such as memory, processors, devices, and information. The operating system correspondingly includes programs to manage these resources, such as a traffic controller, a scheduler, memory management module, I/O programs, and a file system.",
"Kernel is the core part of an operating system which manages system resources. It also acts like a bridge between application and hardware of the computer. It is one of the first programs loaded on start-up.The CPU can execute certain instruction only when it is in the kernel mode. These instruction are called privilege instruction. They allow implementation of special operation whose execution by the user program could interface with the functioning of operating system or activity of another user program. For example, instruction for managing memory protection.The operating system puts the CPU in kernel mode when it is executing in the kernel so, that kernel can execute some special operation.The operating system puts the CPU in user mode when a user program is in execution so, that user program cannot interface with the operating system program.The concept of modes can be extended beyond two, requiring more than a single mode bit CPUs that support virtualization use one of these extra bits to indicate when the virtual machine manager, VMM, is in control of the system. The VMM has more privileges than ordinary user programs, but not so many as the full kernel.",
"In computing, a system call is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on. A system call is a way for programs to interact with the operating system. A computer program makes a system call when it makes a request to the operating system’s kernel. System call provides the services of the operating system to the user programs via Application Program Interface(API). It provides an interface between a process and operating system to allow user-level processes to request services of the operating system. System calls are the only entry points into the kernel system. All programs needing resources must use system calls.While creating a process the operating system performs several operations. To identify the processes, it assigns a process identification number (PID) to each process. As the operating system supports multi-programming, it needs to keep track of all the processes. For this task, the process control block (PCB) is used to track the process’s execution status. Each block of memory contains information about the process state, program counter, stack pointer, status of opened files, scheduling algorithms, etc. All these information is required and must be saved when the process is switched from one state to another. When the process makes a transition from one state to another, the operating system must update information in the process’s PCB.",
"Preemptive scheduling is used when a process switches from running state to ready state or from waiting state to ready state. The resources (mainly CPU cycles) are allocated to the process for the limited amount of time and then is taken away, and the process is again placed back in the ready queue if that process still has CPU burst time remaining. That process stays in ready queue till it gets next chance to execute.Non-preemptive Scheduling is used when a process terminates, or a process switches from running to waiting state. In this scheduling, once the resources (CPU cycles) is allocated to a process, the process holds the CPU till it gets terminated or it reaches a waiting state. In case of non-preemptive scheduling does not interrupt a process running CPU in middle of the execution. Instead, it waits till the process complete its CPU burst time and then it can allocate the CPU to another process.In preemptive scheduling the CPU is allocated to the processes for the limited time whereas in Non-preemptive scheduling, the CPU is allocated to the process till it terminates or switches to waiting state.",
"Internet Of Everything has been the one of the trendiest topic lately and it’s here, IoE is the upcoming most innovative and Ubiquitous technology advancement which is going to make networked connections more relevant and valuable than ever before. Turning information into action that creates new capabilities, richer experiences and unprecedented economic opportunities for businesses, individuals and countries.Technically IoE refers to billions of devices and consumer products connected to the internet in an intelligent networked environment with expanded digital features.It is basically a philosophy in which our technology future is compromised of different types of appliances, devices, and things connected to the global internet.As of now the internet connection is only restricted to Phone’s, PC’s and a handful of other devices but the idea behind IoE is that in the future, Machines will become more intelligent and cognitive by having more access to data and expanded network opportunities.In simpler terms IoE is the intelligent connection of people, process, data and things that will be transforming our world in such a way that there will be billions of connected devices having sensors to detect, measure and access their status all of which will be connected over public or private network built over standard protocols like TCP. ",
]
const paragraphcpp=[
[
  'struct Node',
  '{',
  'int data;',
  'struct Node* next;',
  '};',
  'void printList(struct Node* head)',
  '{',
  'struct Node* ptr = head;',
  'while (ptr)',
  '{',
  'printf("%d -> ", ptr->data);',
  'ptr = ptr->next;',
  '}',
  'printf("NULL\\n");',
  '}',
  'void push(struct Node** head, int data)',
  '{',
  'struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));',
  'newNode->data = data;',
  'newNode->next = *head;',
  '*head = newNode;',
  '}',
  'void reverse(struct Node** head)',
  '{',
  'struct Node* prev = NULL;',
  'struct Node* current = *head;',
  'while (current != NULL)',
  '{',
  'struct Node* next = current->next;',
  'current->next = prev;',
  'prev = current;',
  'current = next;',
  '}',
  '*head = prev;',
  '}',
  'int main(void)',
  '{',
  'int keys[] = { 1, 2, 3, 4, 5, 6 };',
  'int n = sizeof(keys)/sizeof(keys[0]);',
  'struct Node *head = NULL;',
  'for (int i = n - 1; i >=0; i--)',
  'push(&head, keys[i]);',
  'reverse(&head);',
  'printList(head);',
  'return 0;',
  '}',
  'bool isPalindrome(Node* head)',
  '{',
  'stack<int> s;',
  'Node* node = head;',
  'while (node) {',
  's.push(node->data);',
  'node = node->next;',
  '}',
  'node = head;',
  'while (node)',
  '{',
  'int top = s.top();',
  's.pop();',
  'if (top != node->data)',
  'return false;',
  'node = node->next;',
  '}',
  'return true;',
  '}'
],
[
  'void Merge(int arr[], int aux[], int low, int mid, int high)',
  '{',
  'int k = low, i = low, j = mid + 1;',
  'while (i <= mid && j <= high)',
  '{',
  'if (arr[i] <= arr[j])',
  'aux[k++] = arr[i++];',
  'else',
  'aux[k++] = arr[j++];',
  '}',
  'while (i <= mid)',
  'aux[k++] = arr[i++];',
  'copy back to the original array to reflect sorted order',
  'for (int i = low; i <= high; i++)',
  'arr[i] = aux[i];',
  '}',
  'void MergeSort(int arr[], int aux[], int low, int high)',
  '{',
  'if (high == low)',
  'return;',
  'int mid = (low + ((high - low) >> 1));',
  'MergeSort(arr, aux, low, mid); \t',
  'MergeSort(arr, aux, mid + 1, high);',
  'Merge(arr, aux, low, mid, high);',
  '}',
  'int isSorted(int arr[])',
  '{',
  'int prev = arr[0];',
  'for (int i = 1; i < N; i++) {',
  'if (prev > arr[i]) {',
  'printf("MergeSort Fails!!");',
  'return 0;',
  '}',
  'prev = arr[i];',
  '}',
  'return 1;',
  '}',
  'int main(void)',
  '{',
  'int arr[N], aux[N];',
  'srand(time(NULL));',
  'for (int i = 0; i < N; i++)',
  'aux[i] = arr[i] = (rand() % 100) - 50;',
  'MergeSort(arr, aux, 0, N - 1);',
  'if (isSorted(arr)) {',
  'for (int i = 0; i < N; i++)',
  'printf("%d ", arr[i]);',
  '}',
  'return 0;',
  '}',
  'void findPair(int arr[], int n, int sum)',
  '{',
  'for (int i = 0; i < n - 1; i++)',
  '{',
  'for (int j = i + 1; j < n; j++)',
  '{',
  'if (arr[i] + arr[j] == sum)',
  '{',
  'printf("Pair found at index %d and %d", i, j);',
  'return;',
  '}',
  '}',
  '}',
  'printf("Pair not found");',
  '}',
  ''
],
[
  'bool isRotatedPalindrome(string str)',
  '{',
  'int m = str.length();',
  'for (int i = 0; i < m; i++)',
  '{',
  'rotate(str.begin(), str.begin() + 1, str.end());',
  'if (isPalindrome(str, 0, m - 1))',
  'return true;',
  '}',
  'return false;',
  '}',
  'bool isPalindrome(string str, int low, int high)',
  '{',
  'return (low >= high) || (str[low] == str[high] ',
  '&&isPalindrome(str, low + 1, high - 1));',
  '}',
  'string expand(string str, int low, int high)',
  '{',
  'int len = str.length();',
  'while (low >= 0 && high < len && (str[low] == str[high]))',
  'low--, high++;\t\t',
  'return str.substr(low + 1, high - low - 1);',
  '}',
  'string LongestPalindromicSubstring(string str, int len)',
  '{',
  'string max_str = "", curr_str;',
  'int max_length = 0, curr_length;',
  'for (int i = 0; i < len; i++)',
  '{',
  'curr_str = expand(str, i, i);',
  'curr_length = curr_str.length();',
  'if (curr_length > max_length)',
  '{',
  'max_length = curr_length;',
  'max_str = curr_str;',
  '}',
  'curr_str = expand(str, i, i + 1);',
  'curr_length = curr_str.length();',
  'if (curr_length > max_length)',
  '{',
  'max_length = curr_length;',
  'max_str = curr_str;',
  '}',
  '}',
  'return max_str;',
  '}',
  'void interleavings(string res, string X, string Y, auto &collection)',
  '{',
  'if (!X.length() && !Y.length())',
  '{',
  'collection.insert(res);',
  'return;',
  '}',
  'if (X.length())',
  'interleavings(res + X[0], X.substr(1), Y, collection);',
  'if (Y.length())',
  'interleavings(res + Y[0], X, Y.substr(1), collection);',
  '}'
],
[
  'int threeWayPartition(int A[], int end)',
  '{',
  'int start = 0, mid = 0;',
  'int pivot = 1;',
  'while (mid <= end)',
  '{',
  'if (A[mid] < pivot)',
  '{',
  'swap(A, start, mid);',
  '++start, ++mid;',
  '}',
  'else if (A[mid] > pivot)',
  '{',
  'swap(A, mid, end);',
  '--end;',
  '}',
  'else',
  '{',
  '++mid;',
  '}',
  '}',
  '}',
  'bool isConsecutive(int A[], int i, int j, int min, int max)',
  '{',
  'if (max - min != j - i)',
  'return false;',
  'vector<bool> visited(j - i + 1);',
  'for (int k = i; k <= j; k++)',
  '{',
  'if (visited[A[k] - min])',
  'return false;',
  'visited[A[k] - min] = true;',
  '}',
  'return true;',
  '}',
  'void findMaxSubArray(int A[], int n)',
  '{',
  'int len = 1;',
  'int start = 0, end = 0;',
  'for (int i = 0; i < n - 1; i++)',
  '{',
  'int min_val = A[i], max_val = A[i];',
  'for (int j = i + 1; j < n; j++)',
  '{',
  'min_val = min(min_val, A[j]);',
  'max_val = max(max_val, A[j]);',
  'if (isConsecutive(A, i, j, min_val, max_val))',
  '{',
  'if (len < max_val - min_val + 1) {',
  'len = max_val - min_val + 1,',
  'start = i, end = j;',
  '}',
  '}',
  '}',
  '}',
  'cout << "The largest sub-array is [" << start << ", " << end << "]";',
  '}',
  'int sort(int A[], int n)',
  '{',
  'int zeros = 0;',
  'for (int i = 0; i < n; i++) {',
  'if (A[i] == 0) {',
  'zeros++;',
  '}',
  '}',
  'int k = 0;',
  'while (zeros--) {',
  'A[k++] = 0;',
  '}',
  'while (k < n) {',
  'A[k++] = 1;',
  '}',
  '}'
],
[
  'void kadane(int arr[], int n)',
  '{',
  'int max_so_far = 0;',
  'int max_ending_here = 0;',
  'int start = 0, end = 0;',
  'int beg = 0;',
  'for (int i = 0; i < n; i++)',
  '{',
  'max_ending_here = max_ending_here + arr[i];',
  'if (max_ending_here < 0)',
  '{',
  'max_ending_here = 0;',
  'beg = i + 1;',
  '}',
  'if (max_so_far < max_ending_here)',
  '{',
  'max_so_far = max_ending_here;',
  'start = beg;',
  'end = i;',
  '}',
  '}',
  'cout << "The sum of contiguous subarray with the largest sum is " <<',
  'max_so_far << endl;',
  'cout << "The contiguous subarray with the largest sum is ";',
  'for (int i = start; i <= end; i++)',
  'cout << arr[i] << " ";',
  '}',
  'void findSubarray(int arr[], int n, int k)',
  '{',
  'int window_sum = 0;',
  'int min_window = INT_MAX;',
  'int last = 0;',
  'for (int i = 0; i < n; i++)',
  '{',
  'window_sum += arr[i];',
  'if (i + 1 >= k)',
  '{',
  'if (min_window > window_sum)',
  '{',
  'min_window = window_sum;',
  'last = i;',
  '}',
  'window_sum -= arr[i + 1 - k];',
  '}',
  '}',
  'printf("Minimum sum sub-array is (%d, %d)", last-k+1, last);',
  '}',
  'void maxProduct(vector<int> const set, int &maximum)',
  '{',
  'int product = 1;',
  'for (int j : set)',
  'product = product * j;',
  'if (set.size())',
  'maximum = max (maximum, product);',
  '}',
  'void findPowerSet()',
  '{',
  'if (n == 0)',
  '{',
  'maxProduct(set, maximum);',
  'return;',
  '}',
  'set.push_back(S[n - 1]);',
  'findPowerSet(S, set, n - 1, maximum);',
  'set.pop_back();',
  'findPowerSet(S, set, n - 1, maximum);',
  '}'
]
];
module.exports={paragraph,paragraphcpp};
//to split the c++ program
// var fs = require("fs");
// var text = fs.readFileSync("./sample").toString('utf-8');
// //console.log(text);
// var textByLine = text.split("\n")
// console.log(textByLine);